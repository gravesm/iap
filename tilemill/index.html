<!DOCTYPE html>
<html>
    <head>
        <title>TileMill IAP</title>
        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
        <link rel="stylesheet" href="style.css" />
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
    </head>
    <body>
        <div class="container">
            <div class="page-header">
                <h1>TileMill IAP</h1>
            </div>
            <h2>Creating a Road Map</h2>
            <h3>Creating a Project</h3>
            <p>The first thing we're going to do is create a new project. Give it a name, uncheck Default data and click Add. In the left pane is your map and in the right is the CartoCSS controlling the rendering of your map. The two most important buttons in this interface are in the bottom left: the curly braces that bring up the CartoCSS reference and the layers button which is how we will be importing data.</p>
            <p>If you've worked with CSS then CartoCSS should feel familiar. Styles are applied to layers through id and class selectors. The first thing you'll see is the Map selector which is mostly just going to be used to set a background color. We'll go ahead and set the background color to a light blue:</p>
            <pre>
Map {
  background-color: rgb(169,199,214);
}</pre>
            <p>Now, let's add some data. We're going to use Natural Earth datasets because TileMill includes these by default, but you can load data from a number of different formats and locations. Click on the layers button and click the Add layer button. Set the ID to <code>countries</code> and click Browse. The MapBox button will give us access to the Natural Earth datasets. Browse to the <code>natural-earth-1.4.0/cultural/10m-admin-0-countries.zip</code> file and click Done. Go ahead and Save this. We've added a layer, but in order to start applying styles to it, we'll need to create a selector using the ID we just specified. In CartoCSS you do this by prepending the hash symbol to the ID. The styles you want applied go between the curly braces:</p>
            <pre>
#countries {
  polygon-fill: rgb(244,242,241);
  line-color: grey;
  line-width: 0.8;
}</pre>
            <p>Here we are adding a color for the polygon and the polygon outline. There are a number of different ways to specify color in TileMill. You can use hex codes, keyword values, rgb, rgba, hsl and hsla. We're using both rgb and keyword values in this example. Line width values can be specified as integers or floats.</p>
            <p>Now we have our countries displaying, so let's add some roads. Follow the same steps for adding a layer that you just did but set the ID to <code>roads</code> and use the <code>natural-earth-1.4.0/cultural/10m-roads-north-america.zip</code> file. We'll add a basic style to our roads layer, setting the width and color of the lines:</p>
            <pre>
#roads {
  line-width: 0.5;
  line-color: #777777;
}</pre>
            <div class="panel panel-info">
                <div class="panel-heading">Layer Ordering</div>
                <div class="panel-body">If you open up your layer panel you'll note that you can drag the layers around to change the order in which they are drawn. Layers at the top of the list will be drawn on top of layers at the bottom of the list. The ability to control the order in which layers get drawn will be important later when we start working with compositing operations. For now, just make sure your roads layer is on top, otherwise you won't see any roads.</div>
            </div>
            <h3>Attribute Selectors</h3>
            <p>These look like roads, but let's see if we can make some of them, like interstates, stand out. To do that we'll use attribute selectors. You can do some basic viewing of a layer's attributes through the layer panel by clicking on the table icon. This will, at the very least, tell you what attributes are available. In the case of the Natural Earth roads dataset, the CLASS attribute tells us what kind of road it is. We're going to define a selector for this CLASS attribute. We'll start by styling interstates:</p>
            <pre>
#roads {
  line-width: 0.5;
  line-color: #777777;
  [CLASS='Interstate'] {
    line-color: red;
  }
}</pre>
            <p>Attribute selectors appear between square brackets. Here, we're saying that whenever the value of the CLASS attribute is <code>Interstate</code> make the road red. By placing the selector within the roads block, we are allowing it to inherit the properties of the parent block and only override the properties we specify. In this case, we're overriding the color and using the same width for all roads.</p>
            <h3>Attachments</h3>
            <p>One of the techniques you often see used in cartography is to use a casing around roads to make them stand out. We're going to use attachments to achieve this effect. Attachments are a way to apply multiple styles to the same layer. In the same way that the order in which layers get drawn matters, the order in which attachments are applied matters. Attachments are drawn in the order they appear in our stylesheet. An attachment is created by using two colons followed by a label. That label can be anything, it's just a way for you to provide a descriptive clue as to what this attachment is supposed to be doing. Let's look at an example:</p>
            <pre>
#roads {
  line-width: 0.5;
  line-color: #777777;
  [CLASS='Interstate'] {
    ::casing {
      line-color: red;
      line-width: 5;
    }
    ::fill {
      line-color: white;
      line-width: 2;
    }
  }
}</pre>
            <p>What's happening here is that we're drawing the line representing interstates twice, one on top of the other. The ::casing attachment gets drawn first because it appears first in our stylesheet, then the ::fill attachment gets drawn right on top of it. Let's go ahead and do a similar thing for US Highways:</p>
            <pre>
#roads {
  line-width: 0.5;
  line-color: #777777;
  [CLASS = 'Federal'] {
    ::casing {
      line-width: 3;
      line-color: black;
    }
    ::fill {
      line-width: 1.5;
      line-color: white;
    }
  }
  [CLASS='Interstate'] {
    ::casing {
      line-color: red;
      line-width: 5;
    }
    ::fill {
      line-color: white;
      line-width: 2;
    }
  }
}</pre>
            <p>One of the things you'll notice is how our interstates and highways are kind of getting all smashed together into giant roads. What we'd really like is for roads to be distinctly drawn on top of each other. Sometimes, you can use attachments to deal with this, but often, the easiest way to fix this problem is just to duplicate the layer. That's what we'll do here. We want our interstates drawn on top of all the other roads. Go back to your layers panel and add the roads dataset again, this time setting its ID to <code>interstates</code>. Make sure this is on top of the roads layer. We'll move our interstate style out of the <code>#roads</code> block and into a new block:</p>
            <pre>
#interstates [CLASS='Interstate'] {
  ::casing {
    line-color: red;
    line-width: 5;
  }
  ::fill {
    line-color: white;
    line-width: 2;
  }
}</pre>
            <h3>Controlling How Much Data is Rendered</h3>
            <p>One of the great things about TileMill is that it is really fast at rendering tiles. There are limits, though, and if you zoom all the way out, you might notice that it can take a few seconds to draw all those roads. You don't really need to see every single road when you're zoomed out, though. In fact, you can't even make out most of the roads. One of the easiest ways to deal with this is to use the zoom selector. This is like the attribute selector we've been using, except we're filtering based on the zoom level:</p>
            <pre>
#roads {
  [zoom > 6] {
    line-width: 0.5;
    line-color: #777777;
  }
  [zoom > 5] {
    [CLASS = 'Federal'] {
      ::casing {
        line-width: 3;
        line-color: black;
      }
      ::fill {
        line-width: 1.5;
        line-color: white;
      }
    }
  }
}</pre>
            <p>We'll only draw the smaller roads above zoom level 6, the US Highways above zoom level 5, and we'll keep the interstates drawing at all zoom levels. Now we have a bunch of roads, but we don't know which road is which, so let's add some labels to our US Highways. To prevent it from getting too cluttered we'll add labels above zoom level 10:</p>
            <pre>
#roads {
  [zoom > 6] {
    line-width: 0.5;
    line-color: #777777;
  }
  [zoom > 5] {
    [CLASS = 'Federal'] {
      ::casing {
        line-width: 3;
        line-color: black;
      }
      ::fill {
        line-width: 1.5;
        line-color: white;
      }
      [zoom > 10] {
        text-name: "'US ' + [NUMBER]";
        text-face-name: "Ubuntu Bold";
      }
    }
  }
}</pre>
            <p>We use the <code>text-name</code> property to add a label. A feature's attribute values can be accessed by surrounding the attribute name with square brackets. In this example, we're using the NUMBER attribute from the roads layer. Any literal characters we want to appear should be surrounded by single quotes. The plus sign appends two elements of a label together. The <code>text-face-name</code> is required; you can figure out which fonts you have available on your system by clicking on the A button in the lower left-hand corner. You'll note that our labels are appearing below the highway, which is obviously not what we want. Here's a case that's easy to fix with an attachment:</p>
            <pre>
#roads {
  [zoom > 6] {
    line-width: 0.5;
    line-color: #777777;
  }
  [zoom > 5] {
    [CLASS = 'Federal'] {
      ::casing {
        line-width: 3;
        line-color: black;
      }
      ::fill {
        line-width: 1.5;
        line-color: white;
      }
      [zoom > 10] {
        ::label {
          text-name: "'US ' + [NUMBER]";
          text-face-name: "Ubuntu Bold";
        }
      }
    }
  }
}</pre>
            <p>We're getting there, but what we'd really like is for our labels to appear inside the road. In order to do this, we'll need to increase the width of the road and the orientation of the label:</p>
            <pre>
#roads {
  [zoom > 6] {
    line-width: 0.5;
    line-color: #777777;
  }
  [zoom > 5] {
    [CLASS = 'Federal'] {
      ::casing {
        line-width: 3;
        line-color: black;
      }
      ::fill {
        line-width: 1.5;
        line-color: white;
      }
      [zoom > 10] {
        ::casing {
          line-width: 12;
          line-color: black;
        }
        ::fill {
          line-width: 10;
          line-color: white;
        }
        ::label {
          text-name: "'US ' + [NUMBER]";
          text-face-name: "Ubuntu Bold";
          text-placement: line;
        }
      }
    }
  }
}</pre>
            <p>Now we're starting to look pretty good. Let's zoom into Ocracoke, at the southern end of Cape Hatteras off the coast of North Carolina. It shows a road going across to Ocracoke, but you'd be hard pressed to drive it. Let's indicate that this is a ferry. We'll use the TYPE attribute from the layer to select it, and style it as a dashed line:</p>
            <pre>
#roads {
  [zoom > 6] {
    line-width: 0.5;
    line-color: #777777;
    [TYPE='Ferry'] {
      line-width: 1.5;
      line-dasharray: 1,3;
    }
  }
  [zoom > 5] {
    [CLASS = 'Federal'] {
    ...</pre>
            <p>We've made it a little wider so it's easier to see the dashed line. The <code>line-dasharray</code> property is used to create a dashed line. The first number is the length of the dash, and the second number is the length of space between dashes. You can make this as complicated as you want--try setting <code>line-dasharray</code> to 1,3,5,3.</p>
            <p>We're almost done with our road map, but let's add one more layer. Go back to our Natural Earth datasets and add the <code>natural-earth-1.4.0/cultural/10m-railroads.zip</code> layer. We'll just make it blue for the moment so we can see where they are:<p>
            <pre>
#rail {
  line-color: blue;
}</pre>
            <p>Let's make the rail lines have the hatched appearance that's common in maps. TileMill does support using a repeatable image along a line, but in this case, we can actually accomplish what we need with attachments and dashes:</p>
            <pre>
#rail {
  ::line, ::hatch {
    line-color: #555555;
  }
  ::line {
    line-width: 0.8;
  }
  ::hatch {
    line-width: 4;
    line-dasharray: 1, 20;
  }
}</pre>
            <p>What we're doing here is drawing the line twice, like we did with the interstates. The first time is just a plain, thin gray line. The second time is a wider dashed line with the space between dashes exaggerated.</p>
            <p>At this point, although we haven't covered everything, you should have the basics of making maps with vector data. Next up, we'll look at how we can work with raster data and some of the more advanced features, like compositing operations.</p>
            <h2>Creating a Geography Map</h2>
            <p>We're going to start a new project. As with before, give it a name, unncheck Default data and click Add. Let's set our background color here to a gray:</p>
            <pre>
Map {
  background-color: #999;
}</pre>
            <p>Now we'll add our country data set again. Set the ID to <code>countries</code>. This time we're going to store our color in a variable. We do that with the <code>@</code> symbol:<p>
            <pre>@&lt;variable name&gt;:&lt;variable value&gt;</pre>
            <p>It's a good idea to use variables for things you might end up using more than once. We're also going to use HSL values to set our color. HSL, which stands for hue, saturation and lightness, can often be a more intuitive way to think about color. It's also much easier to manipulate using the sorts of operations you often use on colors.</p>
            <p>Defining an HSL value requires three values. I'm going to start with the last value first. This is the lightness of the color, and is probably the easiest to understand. It's stated as a percentage, with 100% being white and 0% being black. The second value is the saturation. This is also represented as a percentage and can sort of be thought of as how vibrant the color is. The first value is the hue. This defines what we might think of primarily as the "color". This is represented as a value from 0-360 and identifies a point on a color wheel. At 0 degrees you'll find red, at 120 degrees is green and at 240 degrees is blue.</p>
            <p>For example, if we want a true red color we would use hsl(0,100%,50%). Green would be hsl(0,100%,50%). Sometimes, you will see people talk about color in terms of cyan, magenta and yellow, rather than red, green and blue. If we think about our color wheel with points at 0, 120 and 240 for red, green and blue, and we rotate it 60 degrees, our points would now represent yellow, cyan and magenta. This is also easy to represent with HSL. For example, yellow would be hsl(60,100%,50%), cyan would be hsl(180,100%,50%) and magenta would be hsl(300,100%,50%). For now, let's just set the land color to a light gray. To do that, we just want to completely desaturate a color--any color (by desaturating, we are basically removing all color)--and increase the lightness:</p>
            <pre>
@land: hsl(0,0%,80%);
#countries {
  polygon-fill: @land;
}</pre>
            <p>Now, let's add an ocean layer and give it some color:</p>
            <pre>
#ocean {
  polygon-fill: hsl(199,35%,55%);
}</pre>
        </div>
    </body>
</html>